/*
 * DynamicArrays.h
 *
 * Copyright 2025, LogEngine2 Project. All rights reserved.
 *
 * See the COPYING file for the terms of usage and distribution.
 */

#ifndef DYNAMIC_ARRAYS_H
#define DYNAMIC_ARRAYS_H

#include <exception> 
#include <string>
#include <format>
#include "Compare.h"

#define valuemin(v1,v2) (((v1)<(v2))?(v1):(v2))
#define valuemax(v1,v2) (((v1)>(v2))?(v1):(v2))

#define DA_EXCEPTION_PREFIX "THArrayException : "
 /*!
  * Class for exceptions. Exceptions of this class are generated by
  * several methods of array classes.
  *
  */
class THArrayException :public std::exception
{
public:
	THArrayException(const char* Message) { Text = Message; whatText = DA_EXCEPTION_PREFIX + std::string(Message); }
	THArrayException(const std::string& Message) { Text = Message; whatText = DA_EXCEPTION_PREFIX + Message; }
	THArrayException(const THArrayException& ex) { Text = ex.Text; whatText = ex.whatText; }
	~THArrayException() noexcept override {} //throw () { }
	THArrayException& operator=(const THArrayException& rhs) { Text = rhs.Text; whatText = rhs.whatText; return *this; }
	virtual std::string getErrorMessage() const { return whatText; }
	const char* what() const noexcept override { return whatText.c_str(); } //throw();
protected:
	THArrayException() {}
private:
	std::string Text;
	std::string whatText; // this is what what() returns as char*
};


//////////////////////////////////////////////////////////////////////
//  AVariant Class Interface
//////////////////////////////////////////////////////////////////////
#ifdef _USE_AVARIANT_

enum AVariantType { vdNull, vdDouble, vdCurrency, vdString, vdInteger, vdDate };

class AVariant {
protected:
	void CopyFrom(const AVariant& v);
public:
	enum AVariantType DataType;
	double AsDouble;
	double AsCurrency;
	std::string AsString;
	int AsInteger;
	int AsDate;

	inline AVariant() { Clear(); }
	AVariant(const AVariant& v) { CopyFrom(v); }
	void operator =(const AVariant& v) { CopyFrom(v); }
	void operator =(const int& v) { SetAsInteger(v); }
	void operator =(const double& v) { SetAsDouble(v); }
	void operator =(const currency& v) { SetAsCurrency(v); }
	void operator =(const std::string& v) { SetAsString(v); }
	inline AVariant(const int v) { SetAsInteger(v); }
	inline AVariant(const double v) { SetAsDouble(v); }
	inline AVariant(const currency v) { SetAsCurrency(v); }
	inline AVariant(std::string& v) { SetAsString(v); }
	inline AVariant(char* v) { SetAsString(v); }
	inline void Clear();
	inline void SetAsDouble(double v);
	inline void SetAsCurrency(const currency v);
	inline void SetAsString(const std::string& v);
	inline void SetAsString(char* v);
	inline void SetAsInteger(const int v);
	inline void SetAsDate(int v);
	void operator +=(AVariant& v);
	bool HaveData();
};

#endif


/*! \brief Class for storing and manipulating raw data types
 * i.e. data which do not have explicit type or the type can be changed dynamically.
 * All that THArrayRaw need to know is ItemSize in bytes of stored data. 
 * All items should have the same size = ItemSize
 * Very useful to store fields from database table.
 */
class THArrayRaw
{
protected:
	uint	FCount;    // number of items in the array
	uint	FCapacity; // amount of memory allocated for storing items, FCapacity >= Fcount always
	uint	FItemSize; // size in bytes of one element in array
	void*	FMemory;
	void	Error(const uint Value, const uint vmax) const;

	// Increase capacity to the next level (usually adding 25% to existing capacity)
	void	Grow();
	
	// Increase capacity to the max(ToCount, increase_after_Grow()_call) elements.
	// if ToCount < Capacity then nothing is done 
	void	GrowTo(const uint ToCount);

	void*	CalcAddr(const uint num) const { return static_cast<void*>(static_cast<uint8_t*>(FMemory) + static_cast<size_t>(num) * FItemSize); }
	[[noreturn]] void	ThrowZeroItemSize() const { throw THArrayException("Error in THArrayRaw: ItemSize cannot be zero!"); }
public:
	THArrayRaw(); // sets ItemSize to default value 1
	THArrayRaw(const uint ItemSize); // array will store elements of ItemSize each (in bytes)
	virtual ~THArrayRaw() { ClearMem(); }
	//	void operator=(const THArrayRaw& a);

	// sets new size of each element in the array
	// if new size differs from existing one - all data in array is cleared before setting new item size.
	// if Size=0 then exception is thrown
	void		SetItemSize(const uint ItemSize); 
	uint		GetItemSize() const { return FItemSize; }
	
	// just zeroes number of elements in the array.
	// allocated memory remains allocated
	virtual void Clear() { FCount = 0; }

	// zeroes number of elements in the array and frees all allocated memory for array items.
	void		ClearMem();

	// Adds new element at the end of the array
	// pValue should point to the element of ItemSize size
	uint		Add(const void* pValue) { return Insert(FCount, pValue); }
	
	// Adds Count elements to the array. elements added at the and of the array.
	// pValue points to the first element being added, pValue + ItemSize points to the second element and so on
	// pValue should be at least Count*ItemSize bytes length  
	void		AddMany(const void* pValue, const uint Count);

	// Inserts element into array to the Index position
	// Index should be in a range from 0 to FCount inclusively
	// Exception is thrown is Index is out of bounds
	uint		Insert(const uint Index, const void* pValue);

	// Inserts Count elements to the array starting from position Index. 
	// pValue points to the first element being added, pValue + ItemSize points to the second element and so on
	// pValue should be at least Count*ItemSize bytes length  
	// Exception is thrown is Index is out of bounds
	void		InsertMany(const uint Index, const void* pValue, const uint Count); // pValue should have at least Count*ItemSize bytes length  
	
	// Replaces element in the array with new value pointer by pValue
	void		Update(const uint Index, const void* pValue);

	// Replaces many elements by the values pointed by pValue
	// pValue points to the first element being added, pValue + ItemSize points to the second element and so on
	// pValue should be at least Count*ItemSize bytes length  
	// Exception is thrown is Index is out of bounds
	void		UpdateMany(const uint Index, const void* pValue, const uint Count); // pValue should have at least Count*ItemSize bytes length  
	void*		GetAddr(const uint Index) const { Error(Index, FCount); return CalcAddr(Index); }
	
	// Deletes element with index Index. all other element are shifted.
	// Exception is thrown is Index is out of bounds
	virtual	void Delete(const uint Index);
	
	// Copies element with index Index to the memory pointed by pValue.
	// pValue should be at least ItemSize size
	void		Get(const uint Index, void* pValue) const;
	
	// Return pointer to the element in array
	// Exception is thrown is Index is out of bounds
	void*		GetPointer(const uint Index) const { return GetAddr(Index); }
	
	// Frees unused memory. Capacity=Count after this call
	void		Hold() { SetCapacity(FCount); }
	//void		MoveData(const int FromPos, const int Count, const int Offset);
	
	// Returns number of element in the array
	uint		Count()    const { return FCount; }

	// Amount of memory allocated in the array for current and future elements 
	uint		Capacity() const { return FCapacity; }

	// Pointer to the first element in the array
	void*		Memory()  const { return FMemory; }

	// Zeroes all data in the array
	void		Zero() { if (FCount > 0) memset(FMemory, 0, static_cast<size_t>(FCount) * FItemSize); }
	
	void		SetCapacity(const uint Value);

	// Adds Count element to the array and set them to zero.
	void		AddFillValues(const uint Count);
 
	void		Swap(const uint Index1, const uint Index2);
};


/*!
 * The base for all  the classes in the library. THArrayBase is an
 * abstract class declaring only virtual methods manipulating arrays. It is
 * not a template class therefore it contains only type independent methods
 */

class THArrayBase
{
public:
	static const int NPOS = -1;  // return value that usually mean "item is not found", this value returned by functions like IndexOf()
	virtual ~THArrayBase() {}
	virtual void Error(const uint Value, const uint vmax) const { if (Value >= vmax) throw THArrayException("Element with index " + std::to_string(Value) + " not found!");	}
	virtual uint Add(const void*) = 0;
	//virtual	void	AddMany(const void* Values) = 0; not implememnted
	virtual void AddFillValues(const uint Count) = 0;
	virtual uint Capacity() const = 0;
	virtual uint Count() const = 0;
	virtual void Clear() = 0;
	virtual void ClearMem() = 0;
	virtual	void DeleteValue(const uint Index) = 0;
	virtual uint Insert(const uint Index, const void* Value) = 0;
	virtual uint ItemSize() const = 0;
	virtual void Hold() = 0;
	virtual void SetCapacity(const uint Value) = 0;
	virtual void Zero() = 0;
	virtual void Swap(const uint Index1, const uint Index2) = 0;
	/*	void	Reverse ();
		void	Reverse (int endIndex);*/

};


//////////////////////////////////////////////////////////////////////
//  THArrayStringFix Class Interface
//////////////////////////////////////////////////////////////////////

class THArrayStringFix : public THArrayBase
{
private:
	THArrayRaw data;
protected:
	char* GetAddr(const uint Index) const {	return static_cast<char*>(data.GetAddr(Index));	}
public:
	//	void operator=(const THArrayStringFix& a) {
	//		printf("THArrayStringFix =");
	//	}
	THArrayStringFix(uint Length) { data.SetItemSize(Length); }
	~THArrayStringFix() override { ClearMem(); }
	std::string GetValue(const uint Index) const { std::string s(GetAddr(Index), data.GetItemSize()); return s; }
	void	SetValue(const uint Index, const std::string& Value) { data.Update(Index, Value.c_str()); }
	std::string operator[](const uint Index) const { return GetValue(Index); }
	inline uint	Count() const override { return data.Count(); }
	void	Clear()    override { data.Clear(); }
	void	ClearMem() override { data.ClearMem(); }
	void	Zero()     override { data.Zero(); }
	void	Hold()     override { data.Hold(); }
	void	DeleteValue(const uint Index) override { data.Delete(Index); }
	uint	Add(const void* pValue) override       { return data.Add(pValue); }
	uint	AddValue(const std::string& Value)     { return data.Add(Value.c_str()); }
	void	AddFillValues(const uint Count) override { data.AddFillValues(Count); }
	uint	Insert(const uint Index, const void* Value) override { return data.Insert(Index, Value); }
	void	Swap(const uint Index1, const uint Index2) override { data.Swap(Index1, Index2); }
	uint	AddChars(const void* pValue, const uint len);
	void	Reverse();
};


//////////////////////////////////////////////////////////////////////
//  THArray Class Interface
//////////////////////////////////////////////////////////////////////

template<class T>
class THArray : public THArrayBase
{
private:
	// Iterator class for THArray
	// Allows applying to THArray various algorithms from standard <algorithm> file
	// Cont is a type of container for what iterator is created
	template<class Cont>
	class THArrayIterator //: public std::iterator<std::input_iterator_tag, T>
	{	
	public:
		// useful types used by iterator that are public for wide use
		using value_type = typename Cont::item_type;
		using iterator_category = std::random_access_iterator_tag;
		using difference_type = ptrdiff_t; //NOTE! ptrdiff_t is signed type
		using pointer = typename Cont::pointer;
		using reference = typename Cont::reference;

	private:
		inline pointer InRange(const pointer beg, const pointer end, const pointer val) const
		{
			return std::min(end, std::max(val, beg));
		}
		inline pointer InRange(const pointer value) const
		{
			return std::min(FCont->FBegin + FCont->FCount, std::max(value, FCont->FBegin));
		}

	public:
		// ptr pointers to the first element in array for begin() iterator
		// and pointers to the elemetn that goes after last one for the end() iterator
		THArrayIterator(Cont* cont, pointer ptr) : FCont(cont), FPtr(ptr) {}
		THArrayIterator(const THArrayIterator& it) : FCont(it.FCont), FPtr(it.FPtr) {}

		// Define various operators here for proper THArrayIterator work
		bool operator!=(const THArrayIterator& other) const { return FCont != other.FCont || FPtr != other.FPtr; }
		bool operator==(const THArrayIterator& other) const { return FCont == other.FCont && FPtr == other.FPtr; }
		reference operator*() const { return *FPtr; }
		pointer operator->() const { return FPtr; }

		THArrayIterator& operator++() { if (FPtr != FCont->FBegin + FCont->FCount) ++FPtr; return *this; } // Prefix increment
		THArrayIterator operator++(int) { THArrayIterator tmp = *this; ++(*this); return tmp; } // Postfix increment. Return value here should NOT be a reference.
		THArrayIterator& operator--() { if (FPtr != FCont->FBegin) --FPtr; return *this; } // prefix decrement
		THArrayIterator operator--(int) { THArrayIterator tmp = *this; --(*this); return tmp; } // return value here should NOT be a reference.
		THArrayIterator& operator+=(const difference_type add) { FPtr = InRange(FPtr + add); return *this; }

		difference_type operator-(const THArrayIterator& right) const { return FPtr - right.FPtr; }
		THArrayIterator operator-(const difference_type diff) const { return THArrayIterator(FCont, InRange(FPtr - diff)); }
		THArrayIterator operator+(const difference_type diff) const { return THArrayIterator(FCont, InRange(FPtr + diff)); }
		
		bool operator<(const THArrayIterator& other) const { return FPtr < other.FPtr; }
	private:
		Cont* FCont{ nullptr };   // pointer to THArray<T> instance for which iterator is created
		pointer FPtr{ nullptr };  // pointer to current element in iterator
	};

protected:
	uint 	FCount;    // number of elements in the array
	uint	FCapacity; // number of element for which memory is allocated in the array, FCapacity >= FCount always
	T*		FMemory;   // pointer to the allocated memory, in most cases - to the first element in the array
	T*		FBegin;    // pointer to the first element in the array, may differ from FMemory in some cases
	uint	GetGrowDelta();

	// Increase capacity to the next level (usually adding 25% to existing capacity)
	void	Grow();

	inline bool	EnoughCapacity(const uint numItems) { return FBegin + numItems <= FMemory + FCapacity; }
	inline void	EnsureCapacity(const uint numItems) { if(!EnoughCapacity(numItems)) GrowTo(numItems); }
public:
	// useful types used by the array and by users
	using iterator = THArrayIterator<THArray>;
	using const_iterator = THArrayIterator<const THArray>;
	using item_type = T;
	using pointer = T*;
	using reference = T&;

	// iterators
	iterator begin() { return iterator(this, FBegin); }
	iterator end()   { return iterator(this, FBegin + FCount); }
	const_iterator cbegin() const { return const_iterator(this, FMemory); }
	const_iterator cend()   const { return const_iterator(this, FMemory + FCount); }

	THArray();
	THArray(const THArray<T>& a);
	~THArray() override { ClearMem(); }

	// allows to initialize array from initialiser list in code, e.g. THArray<std::string> arr = {"s1", "s2", "s3"};
	THArray(std::initializer_list<T> list);
	
	// allows to work with THArray as with array e.g. b = a[i]
	inline T& operator[](const uint Index) const { return GetValue(Index); }
	
	THArray<T>& operator=(const THArray<T>& a); // copy constructor
	bool operator==(const THArray<T>& a) const;

	// one compare operator is enough for now
	bool operator>(const THArray<T>& a) const;

	// readonly method that just calcualted size in bytes of element in the array
	inline uint ItemSize() const override { return sizeof(T); }

	// number of element stored in the array
	inline uint Count() const override { return FCount; }

	// just zeroes number of elements in the array.
	// allocated memory remains allocated
	void		Clear() override { FCount = 0; }
	
	// Amount of memory allocated in the array for current and future elements 
	uint		Capacity() const override { return FCapacity; }
	
	// Frees unused memory. Capacity=Count after this call
	void		Hold() override { SetCapacity(FCount); }
	
	// zeroes number of elements in the array and frees all allocated memory for array items.
	void		ClearMem() override;
	
	// Zeroes all data in the array
	void		Zero() override;

	// Increase capacity to the max(ToCount, increase_after_Grow()_call) elements.
    // if ToCount < Capacity then nothing is done 
	void		GrowTo(const uint ToCount);
	
	// Sets new array capacity
	// if Value < current Capacity then extra elements are deleted
	void		SetCapacity(const uint Value) override;

	// Sets count of element in array to Count
	// No actual element are added, new element will contain "garbage"
	// This function may be useful before mass updating of elements
	void		SetCount(const uint Count);
	
	// Updates element with index Index with new Value
	// Exception is thrown is Index is out of bounds
	void		SetValue(const uint Index, const T& Value);

	// Return reference to the element with indexIndex
	// Reference allows to modify element in the array
	T&			GetValue(const uint Index) const;

	// Inserts new element Value into position Index
	// Returns index of inserted element
	virtual uint InsertValue(const uint Index, const T& Value);
	
	// The same as InsertValue but element is refered by pointer pValue
	// Returns index of inserted element
	uint		Insert(const uint Index, const void* pValue) override { return InsertValue(Index, *static_cast<const T*>(pValue)); }
	
	// Deletes element at position Index from array
	// All right element are shifted in memory accordingly
	void		DeleteValue(const uint Index) override;

	// Adds new element to the end of the array.
	// Return index of added element
	virtual uint AddValue(const T& Value) { return InsertValue(FCount, Value); }

	// The same as AddValue but element is refered by pointer pValue.
	// Returns index of added element
	uint		Add(const void* pValue) override { return AddValue(*static_cast<const T*>(pValue)); }

	// Returns pointer to the value with index Index in the array
	// Returns nullptr if no element with Index exist in the array. No exception is thrown.
	inline	 T* GetValuePointer(const uint Index) const;

	//virtual int IndexOf(const T& Value, const Compare<T>& cmp) const { return IndexOfFrom(Value, 0, cmp); }
	// Tries to find element with value Value in the array
	// Return index of fount element or -1 if element is not found
	// Comparator class Cmp is used to compare element to each other
	template<class Cmp> int IndexOf(const T& Value) const { return IndexOfFrom<Cmp>(Value, 0); }
	
	// the same is IndexOf but seach is started from element from index Start
	template<class Cmp> int	IndexOfFrom(const T& Value, const uint Start) const;
	
	// Finds element in array by comparing them with = operator
	// Elements stored in the array should suppoprt comparing by operator =
	virtual int IndexOf(const T& Value) const { return IndexOfFrom(Value, 0); }

	// the same is IndexOf but seach is started from element from index Start
	virtual int IndexOfFrom(const T& Value, const uint Start) const;
	
	// Adds Count elements to the array. Elements are initialised by default constructor like T()
	void		AddFillValues(const uint Count) override;

	// the same as AddValue call. Usefull when array is used as stack
	virtual void Push(const T& Value) { AddValue(Value); }

	// Return last element in array and deletes it from array
	virtual T    Pop();

	// Return first element in array and deletes it from array
	virtual T    PopFront();

	// Returns last element in the array (without deleting it)
	virtual T&	 Last() const { return GetValue(FCount - 1); }

	void		 Swap(const uint Index1, const uint Index2) override;
	virtual void Reverse();
	virtual void Reverse(uint endIndex); // Reverse till specified element
#ifdef _USE_STREAMS_
	void		SaveToStream(TStream& stre);
#endif

};


//////////////////////////////////////////////////////////////////////
//  THArraySorted Class Interface
//////////////////////////////////////////////////////////////////////

// Stores elements in sorted order
// Sorting rules are defined by comparator class Cmp passed as type parameter of THArraySorted.
// Comparator class should implement three methods: eq(), lt(), mt(). See class Compare<T> for details.
template<class T, class Cmp = Compare<T> >
class THArraySorted : public THArray<T>
{
protected:
	Cmp		FCompare;
private:
	// all functions that can break sorting in an array are moved to private or deleted
	// because adding of element may actually put it in any place in the middle depending on sorting rules
	void	SetValue(const uint Index, const T& Value) = delete;
	uint	Insert(const uint Index, const void* Value)   override { return THArray<T>::Insert(Index, Value); }
	void	AddFillValues(const uint Count) override { THArray<T>::AddFillValues(Count); }
	void	Push(const T& Value) override { THArray<T>::Push(Value); }
	T		Pop()	   override { return THArray<T>::Pop(); }
	T		PopFront() override { return THArray<T>::PopFront(); }
	void	Swap(const uint Index1, const uint Index2) override { THArray<T>::Swap(Index1, Index2); }
	void	Reverse() override { THArray<T>::Reverse(); }
	void	Reverse(uint endIndex) override { THArray<T>::Reverse(endIndex); }
protected:
	// used to insert value into proper position after position is calculated according to sorting rules 
	uint	InsertValue(const uint Index, const T& Value) override { return THArray<T>::InsertValue(Index, Value); }
	
	// returns either index of found element as positive value or negative value -(Index_where_to_put_new_element + 1) when element is not found
	int		InternalIndexOfFrom(const T& Value, const uint Start) const;
public:
	// inserts new value into position according to sorting rules
	uint	AddValue(const T& Value) override;

	// two IndexOf methods look for element in an sorted array using fast binary search algorithm.
	// returns -1 when element is not found 
	int		IndexOfFrom(const T& Value, const uint Start) const override;
	int		IndexOf(const T& Value) const override { return this->IndexOfFrom(Value, 0); }

};


//////////////////////////////////////////////////////////////////////
//  THArrayAuto Class Interface
//////////////////////////////////////////////////////////////////////
/**
* This class never generates an exceptions like "Index out of bounds."
* When out of bounds index being requested (via GetValue or SetValue), array just expanded to the size that covers requested index.
* new space is filled by empty values T().
*/
template<class T>
class THArrayAuto :public THArray<T>
{
protected:
	// if Index >=FCount then add extra elements to array to make sure that at least Index elements present in the array
	// all elements are initialized as T() (default constructor called for each element)
	// does nothing if Index < FCount 
	void	EnsureValue(const int Index);
public:
	// Add elements to make sure that array contains at least Index elements, then sets Index element into Value value
	void    SetValue(const int Index, const T& Value) override;
	
	// GetValue is not const method because it can add elements into array.
	// if Index >= FCount then GetValue add extra elements into array to make sure that at least Index elements present in the array
	// they it returns element at Index position
	// Does not make any changes in array when Index < FCount 
	T& GetValue(const int Index) override;

	// works the same as GetValue below but returns pointer to the element in the arrray
	// never returns nullptr.
	inline  T* GetValuePointer(const int Index) override;
};

//////////////////////////////////////////////////////////////////////
//  THash Class Interface
//////////////////////////////////////////////////////////////////////

/**
* THash class stores pairs of values Key (can be any type) and Value (can be any type too)
* Values can be accessed by Key or also by integer Index (like usual array). 
* Value Indexes (not Keys) are not preserved and may change depending on which pairs Key:Value are stored in the hash
* THash defines an iterator that can be used with any functions from <algorithm> file
* Comparator Cmp used to order Keys in THash for fater search (binary search used to find keys)
*/
template <class I, class V, class Cmp = Compare<I> >
class THash
{
private:
	template<class Hash>
	class THashIterator
	{
	public:
		using value_type = std::pair<typename Hash::KeyType&, typename Hash::ValueType&>;
		using iterator_category = std::random_access_iterator_tag;
		using difference_type = ptrdiff_t;
		using pointer = value_type*;
		using reference = value_type&;

		//THashIterator(const THashIterator& it) : FCont(it.FCont), FCurIndex(it.FCurIndex) {}
		THashIterator(Hash* cont, uint curr) : FCont(cont), FCurIndex(curr) {}

		bool operator!=(THashIterator const& other) const { return FCont != other.FCont || FCurIndex != other.FCurIndex; }
		bool operator==(THashIterator const& other) const { return FCont == other.FCont && FCurIndex == other.FCurIndex; }
		THashIterator& operator++() { if (FCurIndex < FCont->Count()) ++FCurIndex; return *this; }
		THashIterator& operator--() { if (FCurIndex > 0) --FCurIndex; return *this; }
		difference_type operator-(const THashIterator& right) const { return FCurIndex - right.FCurIndex; }
		THashIterator operator-(const difference_type diff) const { return THArrayIterator(FCont, FCurIndex - diff); } //TODO shall we check here that FCurIndex - diff > 0?
		THashIterator operator+(const difference_type diff) const { return THArrayIterator(FCont, FCurIndex + diff); }

		value_type operator*() const { return value_type{ FCont->FAKeys[FCurIndex], FCont->FAValues[FCurIndex] }; }
		//value_type* operator->() const { ??? }
	private:
		Hash* FCont{ nullptr };
		uint FCurIndex{ 0 };
	};

public:
	using KeyType = I;
	using ValueType = V;
	using KeysType = THArraySorted<I, Cmp>;
	using ValuesType = THArray<V>;
	using iterator = THashIterator<THash>;
	using const_iterator = THashIterator<const THash>;
protected:
	KeysType FAKeys;
	ValuesType FAValues;
	Cmp FACompare;
public:
	THash() {}
	THash(const THash<I, V, Cmp>& a);

	// allows to initialize hash from initialiser list in code, e.g. THash<int, std::string> hash = { {1, "s1"}, {30, "s2"}, {1001, "s3"} };
	THash(std::initializer_list<std::pair<I, V>> list);
	
	THash<I, V, Cmp>& operator=(const THash<I, V, Cmp>& other) = default;
	//THash(uint Capacity) { FAKeys.SetCapacity(Capacity); FAValues.SetCapacity(Capacity); }
	virtual ~THash() {}

	iterator begin(){ return iterator(this, 0); }
	iterator end()  { return iterator(this, Count()); }
	const_iterator cbegin(){ return const_iterator(this, 0); }
	const_iterator cend()  { return const_iterator(this, Count()); }

	bool operator==(const THash<I, V, Cmp>& a) const;
	bool operator> (const THash<I, V, Cmp>& a) const;
	V& operator[](const I& key) const { return GetValue(key); }

	// returns Key by ordinary index. this key can be then used to access value associated with this key
	// this is one of the methods to iterate through the hash
	I& GetKey(uint Index) const { return FAKeys.GetValue(Index); }

	// just zeroes number of elements in the array.
	// allocated memory remains allocated
	void	Clear() { FAKeys.Clear(); FAValues.Clear(); }

	// resets number of elements in the hash to zero and frees all allocated memory for hash keys and values.
	void	ClearMem() { FAKeys.ClearMem(); FAValues.ClearMem(); }
	uint	Count() const { return FAKeys.Count(); }
	
	// Returns all keys as a sorted array of Keys
	KeysType& GetKeys() { return FAKeys; }

	// Returns all Values as an unsorted array of values
	ValuesType& GetValues() { return FAValues; }

	bool	IfExists(const I& Key) const;

	// does nothing (and no exception generated ) if element with Key is not found in hash
	void	Delete(const I& Key);

	// If has contains Value with Key this value will be ovewritten by the new value
	// If has does not contain Key -> Key-Value pair will be created in the hash
	void	SetValue(const I& Key, const V& Value);

	// Returns reference to the Value in the hash.
	// Exception is thrown if hash does not contain Key
	// Use IfExists or GetValuePointer to avoid exceptions when Key does not exist in hash
	V& GetValue(const I& Key) const;

	// Returns nullptr when hash does not contain Key;
	// Never throws an exception
	V* GetValuePointer(const I& Key) const;

	// allocates memory for Value items (pairs) in hash
	// does not modiry count of elements in the hash 
	void	SetCapacity(const uint Value) { FAKeys.SetCapacity(Value); FAValues.SetCapacity(Value); }
	//void	Reverse();

/*	void Minus(THash<I, V> in);	*/
};


//////////////////////////////////////////////////////////////////////
//  THash2 Class Interface
//////////////////////////////////////////////////////////////////////
/**
* THash2 can be considered as kind of table where values can be accessed by two keys (two indexes).
* Keys can be any type, indexes can be any type too.
* Comparator Cmp used to order I1 and I2 Keys in THash2 for fater search (binary search used to find keys)
*/
template <class I1, class I2, class V, class Cmp = Compare<I1>>
class THash2
{
public:
	using KeyType = I1;
	using KeysArray = THArraySorted<I1, Cmp>;
	using ValuesHash = THash<I2, V, Cmp>;
	using ValuesArray = THArray<ValuesHash>;
protected:
	THash<I1, ValuesHash, Cmp> FHash;
	uint FCount = 0;
	uint InternalGetCount();
public:
	void Clear() { FHash.Clear(); FCount = 0; }

	// special method when Key2 and Value are empty or do not exist
    // in this case we create Key1 empty section only
    // nothing is done if Key1 section already exist in THash2
	void SetValue(const I1& Key1);

	// all values that correspond to Key1 (regardless to Key2) are replaced by items from Value
	void SetValue(const I1& Key1, const ValuesHash& Value);
	void SetValue(const I1& Key1, const I2& Key2, const V& Value);
	
	// Throws an exception if either Key1 or Key2 not found in the hash2
	V& GetValue(const I1& Key1, const I2& Key2);

	// Throws an exception if Key1 not found in the hash2
	ValuesHash& GetValue(const I1& Key1) { return FHash.GetValue(Key1); }

	// the same as GetValue but returns pointer to Value element in hash2
	// Value element has different types depending on whether we use Key1 or Key1andKey2 to access values in the hash2
	V* GetValuePointer(const I1& Key1, const I2& Key2);
	ValuesHash* GetValuePointer(const I1& Key1) { return FHash.GetValuePointer(Key1); }

	// Delete Does nothing (and no exception is thrown) in case Key1 or Key2 does not exist in hash2.
	void Delete(const I1& Key1, const I2& Key2);

	// Deletes all elements associated with Key1 (regardless Key2)
	void Delete(const I1& Key1);

	bool IfExists(const I1& Key1, const I2& Key2);
	bool IfExists(const I1& Key1) { return FHash.IfExists(Key1); }
	
	inline uint Count() { return FCount; /*hash.Count();*/ }
	
	// one of the ways to iterate through THash2 hash
	I1& GetKey(uint Index) { return FHash.GetKey(Index); }

	KeysArray& GetAIndexes() { return FHash.GetKeys(); }
	ValuesArray& GetAValues() { return FHash.GetValues(); }
	void SetCapacity(const uint Value) { FHash.SetCapacity(Value); }

	//	void Minus(THash2<I1, I2, V>& in);

};


//////////////////////////////////////////////////////////////////////
//  Typedefs Defines
//////////////////////////////////////////////////////////////////////

typedef THArray<std::string> THArrayString;
typedef THArray<int>* PHArrayInt;
typedef THash<std::string, std::string> TStringHash;
typedef THash<std::string, std::string, CompareStringNCase> TStringHashNCase;
// Splits string to array of strings using Delim as delimiter
//void StringToArray(const std::string& str, THArrayString& arr, const char Delim = '\n');
std::string toString(const THArrayString& array);


//////////////////////////////////////////////////////////////////////
//  THArray Class Implementation
//////////////////////////////////////////////////////////////////////

template<class T>
THArray<T>::THArray()
{
	FCount = 0;
	FCapacity = 0;
	FMemory = nullptr;
	FBegin = nullptr;
}

template<class T>
THArray<T>::THArray(const THArray<T>& a) :THArray()
{
	SetCapacity(a.FCount);
	for (uint i = 0; i < a.FCount; i++)
		FBegin[i] = a.FBegin[i];

	FCount = a.FCount;
}

template<class T>
THArray<T>::THArray(std::initializer_list<T> list) :THArray()
{
	for (T item : list)
		AddValue(item);
}

//template<class T>
//void THArray<T>::Error(const uint Value, const uint vmax) const
//{
//	if (Value >= vmax)
//	{
//		//throw THArrayException(std::format("Error in THArray: Element with index {} not found!", Value));
//		throw THArrayException("Error in THArray: Element with index " + IntToStr(Value) + " not found!");
//	}
//}

// calculate grow delta value depending on current array size
template<class T>
uint THArray<T>::GetGrowDelta()
{
	if (FCapacity > 64)
	{
		return FCapacity / 4; // increase by 25% for most cases
	}
	else
	{
		if (FCapacity > 8)
			return 16;
		else
			return 4;
	}
}

/// Grow allocated memory using a special algorithm 
template<class T>
void THArray<T>::Grow()
{
	uint Delta = GetGrowDelta();
	SetCapacity(FCapacity + Delta);
}

// Grows only if not enough Capacity for ToCount elements. if it is grows to either Capacity+25% or to ToCount what is bigger.
template<class T>
void THArray<T>::GrowTo(const uint ToCount)
{
	//if (ToCount <= FCapacity) return; 
	if (EnoughCapacity(ToCount)) return;

	uint Delta = GetGrowDelta();

	//if ((FCapacity + Delta) < ToCount)
	//	Delta = ToCount - FCapacity;
	//SetCapacity(FCapacity + Delta);

	if (FBegin + ToCount > FMemory + FCapacity + Delta)
		SetCapacity(ToCount);
	else
		SetCapacity(FCapacity + Delta);
}

template<class T>
void THArray<T>::SetCapacity(const uint Value)
{
	T* newMemory = nullptr;

	if (Value > 0)
	{
		newMemory = new T[Value];
		for (uint i = 0; i < valuemin(Value, FCount); i++)
			newMemory[i] = FBegin[i];
	}

	delete[] FMemory;
	FMemory = newMemory;
	FBegin  = newMemory;
	FCapacity = Value;
	if (FCapacity < FCount)
		FCount = FCapacity;
}

template<class T>
void THArray<T>::SetCount(const uint Count)
{
	if (Count > FCapacity) GrowTo(Count);
	FCount = Count;
}

template<class T>
void THArray<T>::Reverse()
{
	if (FCount < 2)
		return;

	for (uint i = 0; i < FCount / 2; i++)
	{
		Swap(i, FCount - 1 - i);
	}
}

// Reverse array till specified element
// Elements with index more than endIndex will not be reversed
// After Reverse element with index endIndex will have index 0,
// and element with index 0 will have index endIndex
template<class T>
void THArray<T>::Reverse(uint endIndex)
{
	if (FCount < 2) return;
	if (endIndex == 0) return;

	if (endIndex >= FCount)
		endIndex = FCount - 1;

	for (uint i = 0; i < (endIndex + 1) / 2; i++)
	{
		Swap(i, endIndex - i);
	}
}

template<class T>
THArray<T>& THArray<T>::operator=(const THArray<T>& a)
{
	Clear(); // assignor and assignee objects may have different Capacity because Clear() does not clear allocated memory 
	SetCapacity(a.FCount);

	//memcpy(FMemory, a.FMemory, sizeof(T) * a.FCount);
	for (uint i = 0; i < a.FCount; i++)
		FBegin[i] = a.FBegin[i];

	FCount = a.FCount;

	return *this;
}

template<class T>
bool THArray<T>::operator==(const THArray<T>& a) const
{
	if (FCount == a.FCount)
		return memcmp(FBegin, a.FBegin, FCount * sizeof(T)) == 0; //TODO if T is not simple type memcmp might not work properly due to vtable pointer
	else
		return false;
}

template <class T>
bool THArray<T>::operator>(const THArray<T>& a) const
{
	for (uint i = 0; i < valuemin(FCount, a.Count()); i++)
	{
		if (FBegin[i] > a[i])
			return true;
		else if (a[i] > FBegin[i])
			return false;
	}

	if (FCount > a.Count()) return true;

	return false;
}

template<class T>
void THArray<T>::Zero()
{
	for (uint i = 0; i < FCount; i++)
		FBegin[i] = T();
}

template<class T>
void THArray<T>::ClearMem()
{
	delete[] FMemory;
	FMemory = nullptr;
	FBegin = nullptr;
	FCount = 0;
	FCapacity = 0;
}

template<class T>
void THArray<T>::SetValue(const uint Index, const T& Value)
{
	Error(Index, FCount);
	FBegin[Index] = Value;
}

template<class T>
T& THArray<T>::GetValue(const uint Index) const
{
	Error(Index, FCount);
	return FBegin[Index];
}

template<class T>
uint THArray<T>::InsertValue(const uint Index, const T& Value)
{
	Error(Index, FCount + 1);

	//if (FCount >= FCapacity) Grow();
	EnsureCapacity(FCount + 1);

	if (Index < (FCount >> 1) && // check which part (left or right) of an array is smaller and move data of that part 
		FBegin > FMemory)   // make sure that we have free space on the left 	
	{
		FBegin--;
		for (uint i = 0; i < Index; i++)
			FBegin[i] = FBegin[i + 1];
	}
	else
	{
		for (uint i = FCount; i > Index; i--)
			FBegin[i] = FBegin[i - 1];
	}

	FBegin[Index] = Value;
	FCount++;

	return Index;
}

template<class T>
void THArray<T>::DeleteValue(const uint Index)
{
	Error(Index, FCount);

	//if (Index == 0) PopFront();
	//else if (Index == FCount - 1) Pop();
	//else 
		
	if (Index < (FCount >> 1))  // check which part (left or right) of an array is smaller and move data of part 
  		 //&& FBegin > FMemory))   // make sure that we have free space on the left 	
	{
		for (uint i = Index; i > 0; i--)
			FBegin[i] = FBegin[i - 1];
		FBegin++;
	}
	else
	{
		for (uint i = Index; i < FCount - 1; i++)
			FBegin[i] = FBegin[i + 1];
	}

	FCount--;
}

template<class T>
inline T* THArray<T>::GetValuePointer(const uint Index) const
{
	Error(Index, FCount);
	return FBegin + Index;
}

template<class T>
template<class Cmp>
int THArray<T>::IndexOfFrom(const T& Value, const uint Start) const
{
	Cmp cmp;
	for (uint i = Start; i < FCount; i++)
	{
		T& v = FBegin[i];
		if (cmp.eq(v, Value))
			return static_cast<int>(i);
	}
	return NPOS;
}

template<class T>
int THArray<T>::IndexOfFrom(const T& Value, const uint Start) const
{
	for (uint i = Start; i < FCount; i++)
		if (FBegin[i] == Value)
			return static_cast<int>(i);
	return NPOS;
}

template<class T>
void THArray<T>::AddFillValues(const uint Count)
{
	EnsureCapacity(FCount + Count);
	//if ((FCount + Num) > FCapacity) GrowTo(FCount + Num);

	for (uint i = FCount; i < FCount + Count; i++)
		FBegin[i] = T();
	FCount = FCount + Count;
}

// return last item in array and delete it from array
template<class T>
T	THArray<T>::Pop()
{
	Error(0, FCount); // just check that array is not empty
	FCount--;
	return FBegin[FCount];
}

template<class T>
T	THArray<T>::PopFront()
{
	Error(0, FCount); // just check that array is not empty
	T tmp = FBegin[0];
	FBegin++;   // no need to move data, just move begin pointer
	FCount--;
	return tmp;
}

template<class T>
inline void THArray<T>::Swap(const uint Index1, const uint Index2)
{
	Error(Index1, FCount);
	Error(Index2, FCount);

	if (Index1 == Index2)
		return;

	T temp = FBegin[Index1];
	FBegin[Index1] = FBegin[Index2];
	FBegin[Index2] = temp;
}

#ifdef _USE_STREAMS_
template<class T>
void THArray<T>::SaveToStream(TStream& stre)
{
	stre << FCount;
	stre.Write(FBegin, FCount * sizeof(T));
}
#endif //_USE_STREAMS_


//////////////////////////////////////////////////////////////////////
//  THArraySorted Class Interface
//////////////////////////////////////////////////////////////////////

template <class T, class Cmp>
uint THArraySorted<T, Cmp>::AddValue(const T& Value)
{
	int index = this->InternalIndexOfFrom(Value, 0);
	uint index2 = index < 0 ? static_cast<uint>(-(index + 1)) : static_cast<uint>(index);
	this->InsertValue(index2, Value);

	return index2;
}

template <class T, class Cmp>
int THArraySorted<T, Cmp>::IndexOfFrom(const T& Value, uint Start) const
{
	int index = this->InternalIndexOfFrom(Value, Start);

	return index < 0 ? THArray<T>::NPOS : index;
}

template <class T, class Cmp>
int THArraySorted<T, Cmp>::InternalIndexOfFrom(const T& Value, const uint Start) const
{
	if (Start >= this->FCount && this->FCount != 0)
	{
/*		char str[100];
#ifdef WIN32 
		sprintf_s(str, 100, "Error in THArraySorted: Start index %i is out of bounds!", Start);
#else
		sprintf(str, "Error in THArraySorted: Start index %i is out of bounds!", Start);
#endif*/
		throw THArrayException(std::format("[THArraySorted] Start index {} is out of bounds!", Start));
	}

	if (this->FCount == 0) return THArray<T>::NPOS;

	uint left = Start, count = this->FCount - Start;
	uint step, middle;

	while (count > 0)
	{
		step = count / 2;
		middle = left + step;
		if (FCompare.mt(Value, this->FBegin[middle]))
		{
			left = middle + 1;
			count -= step + 1;
		}
		else if (FCompare.lt(Value, this->FBegin[middle]))
			count = step;
		else
			return static_cast<int>(middle);
	}

	if (left < this->FCount && FCompare.eq(Value, this->FBegin[left])) return static_cast<int>(left);

	return -static_cast<int>(left + 1);  // return position (with negative sign) where element is going to be according to sorting
}

//////////////////////////////////////////////////////////////////////
//  THArrayRaw Class Implementation
//////////////////////////////////////////////////////////////////////

inline THArrayRaw::THArrayRaw()
{
	FCount = 0;
	FCapacity = 0;
	FItemSize = 1;
	FMemory = nullptr;
}

inline THArrayRaw::THArrayRaw(const uint ItemSize) : THArrayRaw()
{
	if (ItemSize > 0)
		FItemSize = ItemSize;
	else
		ThrowZeroItemSize();
}

/*void THArrayRaw::operator=(const THArrayRaw& a) {
	ClearMem();
	FItemSize=a.FItemSize;
	SetCapacity(a.FCount);
	memmove(FMemory,a.FMemory,FCount*FItemSize);
	Sorted=a.Sorted;
}*/

inline void THArrayRaw::Error(const uint Value, /*const uint vmin,*/ const uint vmax) const
{
	if (/*(vmin > Value) ||*/ (vmax <= Value))
	{
/*		char str[512];
#ifdef WIN32 //__STDC_SECURE_LIB__ //_MSC_VER < 1400
		sprintf_s(str, 512, "Error in HArray: Element with index %i not found!", Value);
#else
		sprintf(str, "Error in HArray: Element with index %i not found!", Value);
#endif*/
		throw THArrayException(std::format("Error in THArray: Element with index {} not found!", Value));
	}
}

inline void THArrayRaw::SetItemSize(const uint Size)
{
	if (Size > 0)
	{
		if (FItemSize != Size) ClearMem();
		FItemSize = Size;
	}
	else
		ThrowZeroItemSize();
}

inline void THArrayRaw::Delete(const uint num)
{
	Error(num, FCount);
	if (num < FCount - 1) // do not need to call memmove if we delete last item.
		memmove(GetAddr(num), GetAddr(num + 1), (FCount - (static_cast<size_t>(num) + 1)) * FItemSize);
	FCount--;
}

inline void THArrayRaw::ClearMem()
{
	Clear();
	FCapacity = 0;
	free(FMemory);
	FMemory = nullptr;
}

inline void THArrayRaw::Get(const uint Index, void* pValue) const
{
	Error(Index, FCount);

	if (pValue != nullptr)
		memmove(pValue, CalcAddr(Index), FItemSize);
}

inline void THArrayRaw::AddMany(const void* pValue, const uint Count)
{
	if (Count == 0)
	{
/*		char str[512];
#ifdef WIN32 //__STDC_SECURE_LIB__//_MSC_VER < 1400
		sprintf_s(str, 512, "AddMany(): invalid parameter 'Count'=%i !", Count);
#else
		sprintf(str, "AddMany(): invalid parameter 'Count'=%i !", Count);
#endif  */
		throw THArrayException(std::format("[AddMany] Invalid parameter 'Count'={} !", Count));
	}

	InsertMany(FCount, pValue, Count);
}

inline uint THArrayRaw::Insert(const uint Index, const void* pValue)
{
	Error(Index, FCount + 1);

	if (FCount >= FCapacity) Grow();

	FCount++;
	memmove(CalcAddr(Index + 1), CalcAddr(Index), (FCount - static_cast<size_t>(Index) - 1) * FItemSize); // make free space
	Update(Index, pValue);

	return Index;
}

inline void THArrayRaw::InsertMany(const uint Index, const void* pValue, const uint Count)
{
	Error(Index, FCount + 1);
	if ((FCount + Count) > FCapacity)
		GrowTo(FCount + Count);

	FCount = FCount + Count;
	memmove(CalcAddr(Index + Count), CalcAddr(Index), (FCount - static_cast<size_t>(Index) - Count) * FItemSize); // make free space
	UpdateMany(Index, pValue, Count);
}

inline void THArrayRaw::Update(const uint Index, const void* pValue)
{
	Error(Index, FCount);
	if (pValue != nullptr)
		memmove(CalcAddr(Index), pValue, FItemSize);
	else
		memset(CalcAddr(Index), 0, FItemSize);
}

inline void THArrayRaw::UpdateMany(const uint Index, const void* pValue, const uint Count)
{
	Error(Index + Count - 1, FCount);
	memmove(GetAddr(Index), pValue, FItemSize * static_cast<size_t>(Count));
}

inline void THArrayRaw::Grow()
{
	uint Delta;

	if (FCapacity > 64)
	{
		Delta = FCapacity / 4;
	}
	else
	{
		if (FCapacity > 8)
			Delta = 16;
		else
			Delta = 4;
	}

	SetCapacity(FCapacity + Delta);
}

inline void THArrayRaw::GrowTo(const uint ToCount)
{
	uint Delta;

	if (ToCount <= FCapacity)
		return;

	if (FCapacity > 64)
		Delta = FCapacity / 4;
	else
	{
		if (FCapacity > 8)
			Delta = 16;
		else
			Delta = 4;
	}

	if ((FCapacity + Delta) < ToCount)
		Delta = ToCount - FCapacity;

	SetCapacity(FCapacity + Delta);
}

inline void THArrayRaw::SetCapacity(const uint Value)
{
	if (Value > 0)
	{
		FMemory = realloc(FMemory, static_cast<size_t>(Value) * FItemSize);
		FCapacity = Value;
	}
	else  // Value == 0
	{
		free(FMemory);
		FMemory = nullptr;
	}

	if (FCount > FCapacity)
		FCount = FCapacity;
}

inline void THArrayRaw::AddFillValues(const uint Count)
{
	if ((FCount + Count) > FCapacity)
		GrowTo(FCount + Count);
	memset(CalcAddr(FCount), 0, static_cast<size_t>(Count) * FItemSize);
	FCount = FCount + Count;
}

inline void THArrayRaw::Swap(const uint Index1, const uint Index2)
{
	Error(Index1, FCount);
	Error(Index2, FCount);

	if (Index1 == Index2) return;

	void* temp = malloc(FItemSize);
	if (temp)
	{
		memcpy(temp, GetAddr(Index1), FItemSize);
		memcpy(GetAddr(Index1), GetAddr(Index2), FItemSize);
		memcpy(GetAddr(Index2), temp, FItemSize);
	}

	free(temp);
}

//////////////////////////////////////////////////////////////////////
//  THArrayStringFix Class Implementation
//////////////////////////////////////////////////////////////////////

inline void THArrayStringFix::Reverse()
{
	std::string temp;
	if (data.Count() <= 1)
		return;
	for (uint i = 0; i < data.Count() / 2; i++)
	{
		temp = GetValue(i);
		data.Update(i, GetValue(data.Count() - 1 - i).data());
		data.Update(data.Count() - 1 - i, temp.data());
	}
}

inline uint THArrayStringFix::AddChars(const void* pValue, const uint len)
{
	uint i;
	char* b;

	b = static_cast<char*>(malloc(data.GetItemSize()));
	memset(b, 0, data.GetItemSize());

	i = valuemin(len, data.GetItemSize());

#ifdef WIN32 //__STDC_SECURE_LIB__ //_MSC_VER < 1400  // less than VS2005
	strncpy_s(b, i, static_cast<const char*>(pValue), i);
#else
	strncpy(b, static_cast<const char*>(pValue), i);
#endif

	i = data.Add(b);
	free(b);
	return i;
}

//////////////////////////////////////////////////////////////////////
//  AVariant Class Implementation
//////////////////////////////////////////////////////////////////////
#ifdef _USE_AVARIANT_

void AVariant::CopyFrom(const AVariant& v)
{
	DataType = v.DataType;
	AsDouble = v.AsDouble;
	AsCurrency = v.AsCurrency;
	AsString = v.AsString;
	AsInteger = v.AsInteger;
	AsDate = v.AsDate;
}

inline void AVariant::Clear()
{
	DataType = vdNull;
	AsCurrency = AsDouble = AsDate = AsInteger = 0;
}

inline void AVariant::SetAsDouble(double v)
{
	DataType = vdDouble;
	AsDouble = v;
}

inline void AVariant::SetAsCurrency(const currency v)
{
	DataType = vdCurrency;
	AsCurrency = v;
}

inline void AVariant::SetAsString(const std::string& v)
{
	DataType = vdString;
	AsString = v;
}

inline void AVariant::SetAsString(char* v)
{
	DataType = vdString;
	AsString = v;
}

inline void AVariant::SetAsInteger(const int v)
{
	DataType = vdInteger;
	AsInteger = v;
}

inline void AVariant::SetAsDate(int v)
{
	DataType = vdDate;
	AsDate = v;
}

void AVariant::operator +=(AVariant& v)
{
	if (DataType == vdNull)
	{
		CopyFrom(v);
		return;
	}

	if (v.DataType == vdNull)
		return;

	switch (DataType)
	{
	case vdInteger:
		AsInteger += v.AsInteger;
		break;
	case vdDouble:
		AsDouble += v.AsDouble;
		break;
	case vdCurrency:
		AsCurrency += v.AsCurrency;
		break;
	case vdString:
		AsString += v.AsString;
		break;
	case vdDate:
		AsDate += v.AsDate;
		break;
	}
}

bool AVariant::HaveData()
{
	switch (DataType)
	{
	case vdDouble:
		return AsDouble != 0;
	case vdCurrency:
		return AsCurrency != 0;
	case vdString:
		return AsString.length() != 0;
	case vdInteger:
		return AsInteger != 0;
	case vdDate:
		return AsDate != 0;
	}

	return false;
}

#endif //_USE_AVARIANT_

//////////////////////////////////////////////////////////////////////
//  THArrayAuto Class Implementation
//////////////////////////////////////////////////////////////////////

template<class T>
void THArrayAuto<T>::EnsureValue(const int Index)
{
	if (Index >= this->FCount) AddFillValues(Index - this->FCount + 1);
}

template<class T>
void THArrayAuto<T>::SetValue(const int Index, const T& Value)
{
	EnsureValue(Index);
	THArray<T>::SetValue(Index, Value);
}

template<class T>
T& THArrayAuto<T>::GetValue(const int Index)
{
	EnsureValue(Index);
	return THArray<T>::GetValue(Index);
}

template<class T>
inline T* THArrayAuto<T>::GetValuePointer(const int Index)
{
	EnsureValue(Index);
	return THArray<T>::GetValuePointer(Index);
}


//////////////////////////////////////////////////////////////////////
//  THash Class Implementation
//////////////////////////////////////////////////////////////////////

template <class I, class V, class Cmp>
THash<I, V, Cmp>::THash(std::initializer_list<std::pair<I, V> > list)
{
	for (const auto& pair : list) 
		SetValue(pair.first, pair.second);
}

template <class I, class V, class Cmp>
THash<I, V, Cmp>::THash(const THash<I, V, Cmp>& a)
{
	FAKeys = a.FAKeys;
	FAValues = a.FAValues;
	FACompare = a.FACompare;
}

template <class I, class V, class Cmp>
bool THash<I, V, Cmp>::operator==(const THash<I, V, Cmp>& a) const
{
	return (FAKeys == a.FAKeys) && (FAValues == a.FAValues);// && (FACompare == a.FACompare);
}

template <class I, class V, class Cmp>
bool THash<I, V, Cmp>::operator>(const THash<I, V, Cmp>& a) const
{
	return (FAKeys > a.FAKeys) && (FAValues > a.FAValues);// && (a.FACompare == b.FACompare);
}

/*
template <class I, class V>
void THash<I,V>::Reverse()
{
	if(FAKeys.Count() < 2)
		return;

	for(uint i = 0; i < FAKeys.Count()/2; i++)
	{
		replace(i, FAKeys.Count() - 1 - i);
	}
}
*/

template <class I, class V, class Cmp>
bool THash<I, V, Cmp>::IfExists(const I& Key) const
{
	return (FAKeys.IndexOf(Key) >= 0);
	//if (FAKeys.IndexOf(Key) != DA_NPOS)
	//	return true; 
	//else 
	//	return false;
}

template <class I, class V, class Cmp>
void THash<I, V, Cmp>::Delete(const I& Key)
{
	int n = FAKeys.IndexOf(Key);
	if (n >= 0)
	{
		FAKeys.DeleteValue(static_cast<uint>(n));
		FAValues.DeleteValue(static_cast<uint>(n));
	}
}

template <class I, class V, class Cmp>
void THash<I, V, Cmp>::SetValue(const I& Key, const V& Value)
{
	int n = FAKeys.IndexOf(Key);
	if (n >= 0)
		FAValues.SetValue(static_cast<uint>(n), Value);
	else
	{
		uint index = FAKeys.AddValue(Key);
		FAValues.InsertValue(index, Value); // insert value in the same position returned by keys
	}
}

template <class I, class V, class Cmp>
V& THash<I, V, Cmp>::GetValue(const I& Key) const
{
	int n = FAKeys.IndexOf(Key);
	if (n < 0)
		throw THArrayException("THash<I,V>::GetValue(Key) : Key not found !");

	return FAValues[static_cast<uint>(n)];
}

template <class I, class V, class Cmp>
V* THash<I, V, Cmp>::GetValuePointer(const I& Key) const
{
	int n = FAKeys.IndexOf(Key);
	if (n < 0)
		return nullptr;
	return FAValues.GetValuePointer(static_cast<uint>(n));
}

/*template <class I,class V>
void THash<I,V>::Minus(THash<I, V> in)
{
	I Key;
	for (int i=0; i<FAKeys.Count(); i++)
	{
		Key = FAKeys.GetValue(i);
		if (in.FAKeys.IndexOf(Key) != -1) FAValues.SetValue(i, FAValues.GetValue(i) - in.FAValues.GetValue(in.FAKeys.IndexOf(Key)));
	}
	for (i=0; i<in.FAKeys.Count(); i++)
	{
		Key = in.FAKeys.GetValue(i);
		if (FAKeys.IndexOf(Key) != -1) continue;
		else SetValue(Key, -in.FAValues.GetValue(i));
	}
}*/


//////////////////////////////////////////////////////////////////////
//  THash2 Class Implementation
//////////////////////////////////////////////////////////////////////

template <class I1, class I2, class V, class Cmp>
uint THash2<I1, I2, V, Cmp>::InternalGetCount()
{
	uint result = 0;

	//for each (I1& a in GetAIndexes())
	//{
	//	ValuesHash& val = hash.GetValue(a);
	//	result += val.Count();
	//}

	KeysArray& ind = GetAIndexes();
	for (uint i = 0; i < ind.Count(); i++)
	{
		I1 a = ind[i];
		ValuesHash& val = FHash.GetValue(a);
		result += val.Count();
	}

	return result;
}

template <class I1, class I2, class V, class Cmp>
void THash2<I1, I2, V, Cmp>::SetValue(const I1& Key1, const ValuesHash& Value)
{
	FHash.SetValue(Key1, Value);
	FCount = InternalGetCount();
}

// special method when Key2 and Value are empty or do not exist
// in this case we create Key1 empty section only
// nothing is done if Key1 section already exist in THash2
template <class I1, class I2, class V, class Cmp>
void THash2<I1, I2, V, Cmp>::SetValue(const I1& Key1)
{
	if (FHash.GetValuePointer(Key1) == nullptr)
	{
		ValuesHash h;
		FHash.SetValue(Key1, h);
		//	FCount++;
	}

	// do nothing if Key1 already exist in THash2
}

template <class I1, class I2, class V, class Cmp>
void THash2<I1, I2, V, Cmp>::SetValue(const I1& Key1, const I2& Key2, const V& Value)
{
	ValuesHash* InsH = FHash.GetValuePointer(Key1);

	if (InsH != nullptr)
	{
		uint before = InsH->Count();
		InsH->SetValue(Key2, Value);
		uint after = InsH->Count();
		FCount += after - before;
	}
	else
	{
		ValuesHash h;
		h.SetValue(Key2, Value);
		FHash.SetValue(Key1, h);
		FCount++;
	}
}

template <class I1, class I2, class V, class Cmp>
V& THash2<I1, I2, V, Cmp>::GetValue(const I1& Key1, const I2& Key2)
{
	ValuesHash* h = FHash.GetValuePointer(Key1);
	if (h == nullptr)
		throw THArrayException("THash2::GetValue(Key1, Key2) : Key1 not found !");
	return h->GetValue(Key2);
}

template<class I1, class I2, class V, class Cmp>
inline V* THash2<I1, I2, V, Cmp>::GetValuePointer(const I1& Key1, const I2& Key2)
{
	auto p = FHash.GetValuePointer(Key1);
	if (p == nullptr) return nullptr;
	return p->GetValuePointer(Key2);
}

template <class I1, class I2, class V, class Cmp>
void THash2<I1, I2, V, Cmp>::Delete(const I1& Key1, const I2& Key2)
{
	ValuesHash* TempH = FHash.GetValuePointer(Key1);
	if (TempH != nullptr)
	{
		TempH->Delete(Key2);
		FCount--;
	}
	/*if(TempH.Count() == 0)
		hash.Delete(Key1);
	else
		hash.SetValue(Key1, TempH);*/
}

template <class I1, class I2, class V, class Cmp>
void THash2<I1, I2, V, Cmp>::Delete(const I1& Key1)
{
	ValuesHash* h = FHash.GetValuePointer(Key1);
	int c = 0;
	if (h != nullptr)
		c = h->Count();

	FHash.Delete(Key1);
	FCount -= c; //InternalGetCount();
}

template <class I1, class I2, class V, class Cmp>
bool THash2<I1, I2, V, Cmp>::IfExists(const I1& Key1, const I2& Key2)
{
	if (!FHash.IfExists(Key1))
		return false;
	return FHash.GetValuePointer(Key1)->IfExists(Key2);
}

/*
template <class I1, class I2, class V>
void THash2<I1,I2,V>::Minus(THash2<I1, I2, V>& in)
{
	I2 Key;
	for (int i=0; i<hash.Count(); i++)
	{
		Key = hash.GetKey(i);
		if (in.IfExists(Key))
			hash.GetValue(Key).Minus(in.GetValue(Key));
	}
	for (i=0; i<in.Count(); i++)
	{
		Key = in.GetKey(i);
		if (hash.IfExists(Key))
			continue;
		else
		{
			THash<I2,V> temp = in.GetValue(Key);
			for (int dd=0; dd<temp.Count(); dd++)
				temp.SetValue(temp.GetKey(dd), -temp.GetValue(temp.GetKey(dd)));
			hash.SetValue(Key, temp);
		}
	}
}
*/

// split string into array of strings using Delim as delimiter
template<class STRING>
void StringToArray(const STRING& str, THArray<STRING>& arr, const typename STRING::value_type Delim = '\n')
{
	// make sure that STRING is one of instantiations of std::string
	static_assert(std::is_base_of<std::basic_string<typename STRING::value_type, typename STRING::traits_type>, STRING>::value);

	size_t i = 0;
	size_t len = str.length();
	STRING s;
	s.reserve(len);

	while (i < len)
	{
		s.clear();
		while (i < len)
		{
			if (str[i] == Delim)
			{
				i++;
				break;
			}
			s += str[i++];
		}

		if (s.length() > 0)
			arr.AddValue(s);
	}
}

inline std::string toString(const THArrayString& array)
{
	std::string res;
	res.reserve(100ull * array.Count()); // to reduce number of memory re-allocations we assume that each string in array has 100 characters
	for (uint i = 0; i < array.Count(); i++)
	{
		res.append(array[i]);
	}

	return res;
}

// template "instantiation" for char* or char[x] parameters
// e.g. StringToArray("aa;bb;cc", arr, ';');
inline void StringToArray(const std::string& str, THArrayString& arr, const char Delim = '\n')
{
	StringToArray<std::string>(str, arr, Delim);
	/*
	size_t i = 0;
	size_t len = str.length();
	std::string s;
	s.reserve(len);

	while (i < len)
	{
		s.clear();
		while (i < len)
		{
			if (str[i] == Delim)
			{
				i++;
				break;
			}
			s += str[i++];
		}

		if (s.length() > 0)
			arr.AddValue(s);
	}*/
}

#endif //DYNAMIC_ARRAYS_H
